---
title: "Lab3"
author: "SAF"
date: "`r Sys.Date()`"
output: pdf_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
load("W:/CSIT165_RProgramming/_repos/CSIT165-ModData/Module-6/large_list.RData")
load("W:/CSIT165_RProgramming/_repos/CSIT165-ModData/Module-6/large_vector.RData")

```


# [Part 1: Iterations]{.underline}

**[Question 1]{.underline}** *- Creating For and While loops (using large_vector data set)*

**1A.** Use a while loop to assign a new variable, mean_while, as the mean of large_vector.
Use print to display this value.

```{R Part 1a, echo=FALSE}
count <- 1 #Set the initial count start
countLim <- length(large_vector) #Set the count limit
sum <- 0 #intializes the sum value at zero

#while loop adds each vector element as it cycles through and exits when count is complete
while(count <= countLim)
{
  sum <- sum + large_vector[count] #Keeps running sum of each vector element.
  
  count <- count + 1 #counter for loop
}
mean_while <- sum/length(large_vector) #Divides the sum of all the vector elements by the vectors length.

print(mean_while) #Mean of the vector elements
#mean(large_vector) #Test of value   
```

**1B.** Use a for loop to assign a new variable, mean_for, as the mean of large_vector.
Use print to display this value.
```{R Part 1b, echo=FALSE}
count <- 1 #Set the initial count start
countLim <- length(large_vector) #Set the count limit
sum <- 0 #intializes the sum value at zero

#For loop adds each vector element as it cycles through and exits when count is complete
for(i in count:countLim)
{
  sum <- sum + large_vector[count] #Keeps running sum of each vector element.
  count <- count + 1 #counter for loop
}
mean_while <- sum/length(large_vector) #Divides the sum of all the vector elements by the vectors length.

print(mean_while) #Mean of the vector elements
#mean(large_vector) #Test of value   
length(large_vector)
```

**1C.** How are these methods similar and how might vectorized functions be superior?

*These two loops, for and while, using similar methods but with different count validation statements at the top of each loop. Where the     for loop uses (i in count:countLim) for iteration checks and the while loop uses (count <= countLim) to validate the loop count.*

*One example of how vector functions are superior are how they can be mathematically manipulate large amounts of elements within the         vector. For example, the vector "large_vector" holds 2,461,837 elements or numbers. A simple for/while loop is able to quickly run a        summation of each vector element and find isn’t mean.*


**[Question 2]{.underline}** *- Loops vs vectorized functions*

uses the large_vector data set.

For Question 2, parts A and B, we will normalize each element in large_vector by the total sum of large_vector using for loops and the vectorized function mean. Algorithms for each method should be encapsulated within tic and toc to compare computation time as shown in the example below:
After tic and toc encapsulation to show computation times for each method, show that the normalization was done correctly by summing each element in the normalized vector (they should equal one after normalization).

```{R Part 2: initialize timer, echo=FALSE}
library(tictoc)

tic() # Starts timer
Sys.sleep(3) # Suspends execution of R expressions for 3 seconds
toc() # Records current timer and computes elapsed time since the matching call to tic()
## 3.008 sec elapsed*
```


**2A.** *Use vectorized functions to assign a new variable, norm_vectorized, using the normalization described in the question stem. For this question, it is permissible to use vectorized functions to verify that the normalization was done correctly.*

```{R Part 2a, echo=FALSE}
#Eqn-normailize: NormVect = large_vector/(sqrt(sum(large_vector*large_vector)))
tic() # Starts timer

sqr_vector <- large_vector^2 #square the vector
#sqr_vector <- large_vector*large_vector #square the vector

sumVect <- sum(large_vector)

sqrtsum <- sqrt(sum)#Create the square root of the sum value
norm_vectorized <- large_vector/sqrtsum #normalized vector
#print(norm_vectorized)
toc() # Records current timer and computes elapsed time since the matching call to tic()
```

**2B.** *Use a for loop to assign a new variable, norm_loop, using the normalization described in the question stem. For this question, it IS NOT permissible to use vectorized function to calculate total sum (use a for loop).*

```{R Part 2B, echo=FALSE}
#Eqn-normailize: NormVect = large_vector/(sqrt(sum(large_vector*large_vector)))
tic() # Starts timer

sqr_vector <- large_vector^2 #square the vector
#sqr_vector <- large_vector*large_vector #square the vector


#use while loop to sum all the vector elements.
cnt <- 1 #Set the initial count start
cntLim <- length(sqr_vector) #Set the count limit
sum <- 0 #initializes the sum value at zero

#For loop adds each vector element as it cycles through and exits when count is complete
for(i in cnt:cntLim)
{
  sum <- sum + sqr_vector[cnt] #Keeps running sum of each vector element.
  cnt <- cnt + 1 #counter for loop
}

sqrtsum <- sqrt(sum)#Create the square root of the sum value
norm_vectorized <- large_vector/sqrtsum #normalized vector
print(norm_vectorized)
toc() # Records current timer and computes elapsed time since the matching call to tic()
```


**2C.** *Please explain the differences between these methods in terms of implementation, readability, and computation time. Using your own experiences in the workplace (or speculation of experiences for a job you would like to have), how might these differences be significant and what impact would they have?*


**[Question 3]{.underline}** *- Apply vs loops*
use the large_list data set.


**3A.** *Use apply to assign a new variable, mean_list_apply, the mean of each vector in large_list.*
```{R Part 3A, echo=FALSE}
tic() # Starts timer

AllMatrix <- as.matrix(as.data.frame(large_list))#Converts all three sub-lists from large_list into a matrix of one single column.
total <- apply(AllMatrix, 2, sum)

message("A matrix")
length(large_list[[1]])
total[1]
print(total[1]/length(large_list[[1]]))
mean(large_list[[1]])
message("B matrix")
length(large_list[[2]])
total[2]
message("C matrix")
length(large_list[[3]])
total[3]
message("Time lapse")
toc() # Records current timer and computes elapsed time since the matching call to tic()

```

**3B.** *Use for loop to assign a new variable, mean_list_for, the mean of each vector in large_list.*
```{R Part 3B, echo=FALSE}

#use while loop to sum all the vector elements.
  cnt <- 1 #Set the initial count start
  sum <- 0 #initializes the sum value at zero

#For loop adds each vector element as it cycles through and exits when count is complete
for(j in 1:3)
{
#print("-----------------------------------------")
#print("outside loop")
#print(j)
#print("-----------------------------------------")
  
  cntLim <- length(large_list[[j]]) #Set the count limit
  #cntLim <- 4
  for(i in cnt:cntLim)
  {
    #print("inside loop")
    #cntTest <- length(large_list[[j]]) #Set the count limit per matrix
    #print(i)
    sum <- sum + large_list[[j]][[cnt]] #Keeps running sum of each vector element.
  }
}

```

**3C.** *Please explain the differences between these methods in terms of implementation, readability, and computation time. Were these differences surprising? How do you predict these differences will change if we used lists with much more elements (i.e. length(list) > 1000)?*


# [Part 1: Control]{.underline}

Controlling flow is important for manipulating data based on their values. We show how easy R makes control and iteration by comparing the Un-R way with the R way. The Un-R way uses for loops and if/else statements while the R way uses proper subsetting and vectorization. Let’s explore these differences.
use the large_vector data set.

**[Question 4]{.underline}** *- Doing it the Un-R way*

**4A.** *Use the Un-R way, with a for loop and if/else statements, to assign a new variable, nbr_zeros_loop, as the number of zeros that are in large_vector. Print the value of this variable.*
```{R Part 4A, echo=FALSE}


```

**4B.** *Use the Un-R way, with a for loop and if/else statements, to assign a new variable, smaller_vector_loop, as all the values of large_vector that are not equal to zero. Vectorized functions (i.e. na.omit) are permitted but a for loop must be used to iterate through vector. Show that the sum of nbr_zeros_loop and the length of smaller_vector_loop are equal to the length of larger_vector.*
```{R Part 4B, echo=FALSE}


```





**[Question 5]{.underline}** *- Doing it the R-way*
use the large_vector data set.

**5A.** *Use the R way, proper subsetting and vectorized functions, to assign a new variable, nbr_zeros, as the number of zeros that are in large_vector. Print this variable. Show that nbr_zeros and nbr_zeros_loop are equal.*
```{R Part 5A, echo=FALSE}


```

**5B.** *Use the R way, proper subsetting and vectorized functions, to assign a new variable, smaller_vector, as all the values of large_vector that are not equal to zero. Show that the sum of nbr_zeros and the length of smaller_vector are equal to the length of larger_vector.*
```{R Part 5B, echo=FALSE}


```